# This file is NOT licensed under the GPLv3, which is the license for the rest
# of ycmd.
#
# Here's the license text for this file:
#
# This is free and unencumbered software released into the public domain.
#
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
# For more information, please refer to <http://unlicense.org/>

import os
import logging

from ycmd import utils
from ycmd.responses import NoExtraConfDetected
import ycm_core

# Overview
# --------
#
# This file provides an attempt to heuristically provide compiler flags for
# c-family languages. It does this by interrogating a compilation database.
# A compilation database can be generated by tools such as cmake, bear, etc. It
# contains the compiler flags (actually, a compiler invocation) for each source
# file in the project, generated by the make system. If no compilation database
# is found, no flags are generated.
#
# The file is deliberately heavy on comments. This is to allow it to be adapted
# to individual use cases by copying it to a known directory, configuring it
# as the 'global_extra_conf' and customising it to your particular
# environment. Note that the comments in this file are not a replacement for the
# ycmd or YouCompleteMe documentation, nor is is meant to be a replacement for
# the comments/examples found in ycmd's own C++ source location
# (../cpp/ycm/.ycm_extra_conf.py).
#
# Finding the compilation database
# --------------------------------
#
# While there is no standard, and using something like cmake typically involves
# an out-of-tree build, we attempt to find a compilation database by walking the
# directory hierarchy looking for a file named compile_commands.json, starting
# at the path of the file for which flags were requested (i.e. the file being
# edited).
#
# If a compilation database is found, it is cached against the directory it is
# found in, to prevent re-parsing the entire database for every file, while
# allowing a single instance ycmd to operate on multiple "projects" at once.
#
# Guessing flags
# --------------
#
# The compilation database typically only contains flags (compiler invocations)
# for source files known to the make system and/or makefile generator, as these
# form the translation units for which calls to the compiler (typically with the
# -c flag) are actually made. It does not contain:
#  - new files, not yet run through the make generator system
#  - header files
#
# So the logic in this file applies some simple heuristics to guess the flags in
# those cases:
#  - If the file is a header file (according to HEADER_EXTENSIONS)
#    above, see if there is an entry in the database with the same root, but
#    with any of the extensions in SOURCE_EXTENSIONS. If so, return those
#    flags.
#  - Otherwise, if there is an entry in the database for the requested file,
#    return those flags.
#  - Otherwise, we really can't guess any flags, so return none (and thus a
#    warning that we can't guess your flags).
#

# Tweakables for heuristics {{{

# List of file extensions to be considered "header" files and thus not present
# in the compilation database. The logic will try and find an associated
# "source" file (see SOURCE_EXTENSIONS below) and use the flags for that.
HEADER_EXTENSIONS = [ '.h', '.hxx', '.hpp', '.hh' ]

# List of file extensions which are considered "source" files for the purposes
# of heuristically locating the flags for a header file.
SOURCE_EXTENSIONS = [ '.cpp', '.cxx', '.cc', '.c', '.m', '.mm' ]

# List of compiler flags which are considered to be path flags and thus
# requiring modification to ensure they are correctly relative to the compiler
# directory
PATH_FLAGS = [ '-isystem', '-I', '-iquote', '--sysroot=' ]

# }}}

# Caches for heuristically guessing flags {{{

# We cache the database for any given source directory
compilation_database_dir_map = dict()

# Sometimes we don't actually know what the flags to use are. Rather than
# returning no flags, if we've previously found flags for a file in a particular
# directory, return them. The will probably work in a high percentage of cases
# and allow new files (which are not yet in the compilation database) to receive
# at least some flags
file_directory_heuristic_map = dict()

# }}}

# Implementation {{{

_logger = logging.getLogger( __file__ )


# Return a compilation database object for the supplied path or None if none
# could be found.
#
# We search up the directory hierarchy, to first see if we have a compilation
# database already for that path, or if a compile_commands.json file exists in
# that directory.
def FindCompilationDatabase( wd ):
  # Find all the ancestor directories of the supplied directory
  for folder in utils.PathsToAllParentFolders( wd ):
    # Did we already cache a database for this path?
    if folder in compilation_database_dir_map:
      # Yep. Return that.
      _logger.debug( 'Using cached result ({2}) in {0} for {1}'.format(
        folder,
        wd,
        'database' if compilation_database_dir_map[ folder ] else 'None' ) )
      return compilation_database_dir_map[ folder ]

    # Guess not. Let's see if a compile_commands.json file already exists...
    compile_commands = os.path.join( folder, 'compile_commands.json' )
    if os.path.exists( compile_commands ):
      # Yes, it exists. Create a database and cache it in our map.
      database = ycm_core.CompilationDatabase( folder )
      _logger.debug( 'Found compilation database {0} for wd {1}'.format(
          compile_commands,
          wd ) )
      compilation_database_dir_map[ folder ] = database
      return database

    # Doesn't exist. Check the next ancestor

  # Nothing was found. No compilation flags are available.
  #
  # Note: we cache the fact that none was found for this folder to speed up
  # subsequent searches..
  compilation_database_dir_map[ wd ] = None
  return None


# Find the compilation info structure from the supplied database for the
# supplied file. If the source file is a header, try and find an appropriate
# source file and return the compilation_info for that.
def GetCompilationInfoForFile( database, file_name, file_extension ):

  # The compilation_commands.json file generated by CMake does not have entries
  # for header files. So we do our best by asking the db for flags for a
  # corresponding source file, if any. If one exists, the flags for that file
  # should be good enough.
  if file_extension in HEADER_EXTENSIONS:
    # It's a header file
    for extension in SOURCE_EXTENSIONS:
      replacement_file = os.path.splitext( file_name )[ 0 ] + extension
      if os.path.exists( replacement_file ):
        # We found a corresponding source file with the same file_root. Try
        # and get the flags for that file.
        compilation_info = database.GetCompilationInfoForFile(
          replacement_file )
        if compilation_info.compiler_flags_:
          return compilation_info

    # No corresponding source file was found, so we can't generate any flags for
    # this header file.
    return None

  # It's a source file. Just ask the database for the flags.
  compilation_info = database.GetCompilationInfoForFile( file_name )
  if compilation_info.compiler_flags_:
    return compilation_info

  return None


def MakeRelativePathsInFlagsAbsolute( flags, working_directory ):
  if not working_directory:
    return list( flags )
  new_flags = []
  make_next_absolute = False
  for flag in flags:
    new_flag = flag

    if make_next_absolute:
      make_next_absolute = False
      if not flag.startswith( '/' ):
        # TODO/FIXME: Is this startswith here correct on Windows?
        new_flag = os.path.join( working_directory, flag )

    for path_flag in PATH_FLAGS:
      if flag == path_flag:
        make_next_absolute = True
        break

      if flag.startswith( path_flag ):
        path = flag[ len( path_flag ): ]
        new_flag = path_flag + os.path.join( working_directory, path )
        break

    if new_flag:
      new_flags.append( new_flag )
  return new_flags


EMPTY_FLAGS = {
  'flags': [],
}

# }}}

# Entry point {{{


# ycmd calls this method to get the compile flags for a given file. It returns a
# dictionary with 2 keys: 'flags' and 'do_cache', or None if no flags can be
# found.
def FlagsForFile( file_name, **kwargs ):
  file_dir = os.path.dirname( file_name )
  ( file_root, file_extension ) = os.path.splitext( file_name )

  # Create or retrieve the cached compilation database object
  database = FindCompilationDatabase( file_dir )
  if database is None:
    _logger.debug( 'FlagsForFile( {0} ): No compilation database found'.format(
      file_name ) )
    raise NoExtraConfDetected()
  elif not database.DatabaseSuccessfullyLoaded():
    _logger.debug(
      'FlagsForFile( {0} ): Compilation database failed to load'.format(
        file_name ) )
    raise NoExtraConfDetected()

  compilation_info = GetCompilationInfoForFile( database,
                                                file_name,
                                                file_extension )

  if compilation_info is None and file_dir in file_directory_heuristic_map:
    # We previously saw a file in this directory. As a guess, just
    # return the flags for that file. Hopefully this will at least give some
    # meaningful compilation
    _logger.debug( 'FlagsForFile( {0} ): Using flags for directory: {1}'.format(
      file_name,
      file_dir ) )
    compilation_info = file_directory_heuristic_map[ file_dir ]
  else:
    # No cache for this directory and we really can't conjure
    # up any flags from the database.
    _logger.debug( 'FlagsForFile( {0} ): No flags in database'.format(
      file_name ) )
    return EMPTY_FLAGS

  if file_dir not in file_directory_heuristic_map:
    # This is the first file we've seen in path file_dir. Cache the
    # compilation_info for it in case we see a file in the same dir with no
    # flags available
    file_directory_heuristic_map[ file_dir ] = compilation_info

  return {
    # We pass the compiler flags from the database unmodified.
    'flags': MakeRelativePathsInFlagsAbsolute(
      compilation_info.compiler_flags_,
      compilation_info.compiler_working_dir_ ),
  }

# }}}
